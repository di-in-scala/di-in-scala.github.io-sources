
Manual DI isn’t of course a silver bullet. Manually writing new instance creation code for each class, using the correct parameters may be tedious.

That is where [MacWire](https://github.com/adamw/macwire) and the `wire` method can help. `wire` is a [Scala Macro](https://docs.scala-lang.org/scala3/guides/macros/macros.html), which generates the new instance creation code. 

After using MacWire, the code becomes simpler:

````scala
object TrainStation extends App {
   lazy val pointSwitcher = wire[PointSwitcher]
   lazy val trainCarCoupler = wire[TrainCarCoupler]
   lazy val trainShunter = wire[TrainShunter]

   lazy val craneController = wire[CraneController]
   lazy val trainLoader = wire[TrainLoader] 
   lazy val trainDispatch = wire[TrainDispatch]

   lazy val trainStation = wire[TrainStation]

   trainStation.prepareAndDispatchNextTrain() 
} 
````

If a new dependency is added to a service or if the order of parameters changes, the object-graph wiring code doesn’t have to be altered; the macro will take care of that. Only when introducing a new service, it must be added to the list.

The new instance creation code is generated by `wire` at *compile time*, so if you compare the byte code generated by both examples, it will be identical. The generated code is type-checked in the usual way, so we keep the type-safety of the manual approach.

Usage of the `wire` macro can be mixed with creating new instances by hand; this may be needed if, as discussed earlier, creating a new instance isn’t that straightforward.

To access `wire`, you should import `com.softwaremill.macwire._`. For details on how to integrate MacWire into your project, see the [GitHub page](https://github.com/adamw/macwire).

## How `wire` works

Given a class, the `wire` macro first tries to find a constructor annotated with `@Inject`, then the (non-private) primary constructor, and finally an `apply` method in the companion object, to determine the dependencies needed. For each dependency it then looks for a value which conforms to the parameter’s type, in the enclosing method/class/object:

* first it tries to find a unique value declared as a value in the current block, argument of enclosing methods and anonymous functions
* then it tries to find a unique value declared or imported in the enclosing type
* finally it tries to find a unique value in parent types (traits/classes)
* if the parameter is marked as implicit, it is ignored by MacWire and handled by the normal implicit resolution mechanism

Here value can be either a `val`, `lazy val` or a no-parameter `def`, as long as the return type matches.

A compile-time error occurs if:

* there are multiple values of a given type declared in the enclosing block/method/function's arguments list, enclosing type or its parents
* parameter is marked as implicit and implicit lookup fails to find a value
* there is no value of a given type

## Using implicit parameters

A similar effect to the one described above can be achieved by using implicit parameters and implicit values. If all constructor parameters are marked as `implicit`, and all instances are marked as `implicit` when the object graph is wired, the Scala compiler will create the proper constructor calls.

The class definitions then become:

````scala
class PointSwitcher()
class TrainCarCoupler()
class TrainShunter(
   implicit
   pointSwitcher: PointSwitcher, 
   trainCarCoupler: TrainCarCoupler)

class CraneController()
class TrainLoader(
   implicit
   craneController: CraneController, 
   pointSwitcher: PointSwitcher)

class TrainDispatch()

class TrainStation(
   implicit
   trainShunter: TrainShunter, 
   trainLoader: TrainLoader, 
   trainDispatch: TrainDispatch) {

   def prepareAndDispatchNextTrain() { ... }
}
````

And the wiring:

````scala
object TrainStation extends App {
   implicit lazy val pointSwitcher = new PointSwitcher
   implicit lazy val trainCarCoupler = new TrainCarCoupler
   implicit lazy val trainShunter = new TrainShunter

   implicit lazy val craneController = new CraneController
   implicit lazy val trainLoader = new TrainLoader

   implicit lazy val trainDispatch = new TrainDispatch

   implicit lazy val trainStation = new TrainStation

   trainStation.prepareAndDispatchNextTrain()
}
````

However, using implicits like that has two drawbacks. First of all, it is intrusive, as you have to mark the constructor parameter list of each class to be wired as `implicit`. That may not be desireable, and can cause the person reading the code to wonder why the parameters are implicit. 

Secondly, implicits are used in many other places in Scala for other, rather different purposes. Adding a large number of implicits as described here may lead to confusion. Still, such a style may be a perfect fit in some use-cases, of course!
